# Test Scenarios

## Front-end

1. Login Page: The LoginPage allows users to sign in with his/her Google account. Once the user signs in successfully, the interface will jump to the Home Page, and the user would gain a UID and enter the HomePage. If users do not sign in with a Google account, then they could not use the app.

2. Home Page: The HomePage allows users to see the post from other users, including a profile for users, the post details, and awards for the task. If the user likes someone's tasks, he/she could click the "Likes," the number would increase by one if the program generates correctly. Similarly, users would enter the Chat Page successfully if they want to chat with the task owner. If there are errors, the numbers of "Likes" are not able to increase correctly, or the user would not enter other pages.   

3. Task Detail Page: The TaskDetailPage is an extended page called by other pages to show more detailed information for one's task, such as the rating, taskID, title, etc. Within the page, props.navigation is generated by the stack navigator in React-Navigation. If the props.navigation is generated successfully, users could enter other pages; otherwise, he would be stuck on the current page.  

4. Task Page: TaskPage contains the basic navigation logic jump between different taskDetailPage and chatPage. Users can view the list of accepted tasks and published tasks here. The user can pull down the page to refresh it. If there is something change, the list of tasks will be updated. Simultaneously, the user can click the specified task to navigate to its task detail page.

5. Publish Page: The PublishPage collects the new task's input from the users. It publishes the new task and a new post request to the server. If the server receives the request successfully, the server notifies the App.js. Once the user clicks the button which posts the new task, a PublishPage with imagePicker would be rendered. While the users pick a picture he wants to sue, we use checkImagePermission function to check whether the application can access the images in the users' device library. The ImagePicker generates four TouchableOpacity that allows users to upload up to four images for the new task. If the users want to select the fifth picture, they cannot do that, and an error would occur.


6. Message Page: Message Page has a child component ChatList, which is one of the observers under the subject App.js. As soon as the variable chatList changed in App.js, Message Page will re-render and update the new message for the corresponding ChatBox. Message Page also has basic navigation logic to jump between different ChatPage. Users can pull down to refresh the message page manually. 

7. Chat Page: It shows the MapObject and ChatBox for an interactive user chatting experience. When the network is not good, if the user sends a large number of messages in a short period of time, the display of messages may overlap because the message array will append the messages into the same index. If the user resigns again, the messages will display correctly, and the content in the message array will be correct. For the MapObject, it allows users to share their location and display the route between two users.

8. User Page: There are two important functions in the UserPage: Imagepicker and Sign Out. WeHelp allows users to upload their own personalized photos as the profile. Users can click the photo to select their favorite photo from local photo albums. If the process works successfully, the profile photo of the user will be updated. If the user clicks Sign out at the bottom, it will redirect the user to the login page. After the user signs in again, the new profile will be uploaded to the server. If there exist some errors, there will be an alert of detailed information about the errors.

9. User Detail Page: It displays the same content as the User Page, including profile, user name, rating score, etc. Users can pull down to refresh the User Detail Page if there exists any information updating. 

## Back-end

 We have provided four testcases. Three in [server/WeHelpServer/tests.py](server/WeHelpServer/tests.py). And one in [server/WeHelpServer/channelTest.py](server/WeHelpServer/channelTest.py) which can only run on the server (or you can run it locally with some modifications if you have redis server). We use django.test module whose Testcase is a subclass of unittest.Testcase. You can run these in directory \code{server/} with command:

```shell
python manage.py test
```

```shell
python manage.py test WeHelpServer.channelTest
```

1. User Creation Test: The main purpose of this is to test all the users are unique. From the APIs, it will only create users on signIn function. We run signIn function multiple times and make sure the created users are unique. 

2. Chat Message Test: We have created two users Alice and Bob. In setup, Alice sends a message to Bob, and Bob sends a message back to Bob. And they also tried to send/receive to/from a non-existing user. We check that only one chat is created, and its owners are Alice and Bob. The chat also has two messages that matched the setup, and the messages have the correct senderUID.

3. Task Test: In setup, Alice created a Task. We tests **getActiveTask** returns only one task and matches the information. Then we let Bob accept it using function **acceptTask**. Then check Bob's **getAcceptTask** and Alice's **getPublishTask**. After that, Bob cancel the acception using function **cancelAccept** and Alice's **deleteTask** and **finishTask**. Through the entire event, we test both Alice's and Bob's balance, finish_count, publish_count, and contributions.

4. Channel Test: This is to test the Redis server (we use Redis as an in-memory database to log the client connections) and consumers of websockets. They are used to send messages and locations to clients. We first test the messages sent to the correct clients (clients are marked with UID). We open 10 websockets to our server endpoint **ws://34.94.101.183/ws/WeHelp/\<UID\>/** with different uid and send a different message to the channel_layer. And test if they receive the correct messages. After that, we test if one user can log in from multiple devices simultaneously, and each receives a copy of the same message. 
We create 10 websockets to our server with the same uid and send one message to the channel_layer and test each socket receives exactly one copy.